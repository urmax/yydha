---
title: 浏览器渲染原理
date: 2023-05-17
updated: 2023-05-17
tags: 
    - 前端
categories: 
    - js
keywords: js
description: 浏览器渲染原理
---
# 浏览器渲染原理
### 渲染（render）
html字符串 --> 页面的像素信息
|线程|步骤1|步骤2|步骤3|步骤4|步骤5|步骤6|步骤7|步骤8|步骤9|步骤10|
|---|---|---|---|---|---|---|---|---|---|---|
|渲染主线程|parse（解析html，生成dom树和css树）|style（样式计算得到最终的样式）|layout（布局，计算出每一个dom节点的几何信息）|layer（分层，为了提高后续的渲染效率，根据浏览器自己的策略分层，每个图层可以单独去绘制）|paint（绘制指令）|||||||
|合成线程||||||tiling（分块，分成一个一个的小块）|raster（光栅化，换成像素信息并且优先靠近视窗的小块）|draw（把这些小块信息（quad）发送到gpu线程进行下一步）|||
|GPU线程|||||||||GPU线程得到指引信息，产生系统调用传到硬件(显卡）|最终呈现出当前页面|
### 重新排版（重排） reflow （效率影响大，尽量少这么操作）
本质上是重新计算layout树。
指的是用js修改了css树:样式信息（重新计算样式）or dom树的结构然后引起了布局的变化，就会引起重排，导致后续的一系列复杂的操作。
为了避免多次操作导致布局树反复计算，浏览器会合并这些操作，当js代码完成后统一计算。所以改动属性导致的reflow是异步完成的。
也同样因为如此，当js获取布局属性的时候，就可能造成无法获取到最新的布局信息。
浏览器最终权衡，获取布局属性，会立即reflow。

### 重绘 repaint
repaint的本质是重新根据分层信息，计算了绘制指令。
指的是修改了可见的样式，就需要重新计算，就会影响到paint层和之后的操作。
由于布局样式属于可见样式，所以reflow一定会repaint。
### transform 效率高的原因
transform 是在第八步（draw）确定的，只会影响合成线程的draw层，基本不会影响到渲染主线程，所以修改他，不会引起重排或者重绘，这是他效率高的本质原因。
使用js修改了transform 会影响到渲染主线程的style计算及合成线程的draw层。
如果是在css中配合的animation，只影响合成线程的draw层。