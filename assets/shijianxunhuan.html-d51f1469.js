import{_ as e,o as a,c as n,b as r}from"./app-571c1f36.js";const d={},h=r(`<h1 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h1><h3 id="_1-浏览器的进程和线程" tabindex="-1"><a class="header-anchor" href="#_1-浏览器的进程和线程" aria-hidden="true">#</a> 1. 浏览器的进程和线程</h3><pre><code>可以在浏览器的任务管理器中查看当前的所有进程。
其中，最主要的进程有：
1. 浏览器进程
    主要负责界面显示，用户交互，子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。
2. 网络进程
    网络加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。
3. 渲染进程（重要）
    渲染进程启动后，会开启一个渲染主线程，主线程负责执行html，css，js代码。
</code></pre><h3 id="_2-异步" tabindex="-1"><a class="header-anchor" href="#_2-异步" aria-hidden="true">#</a> 2. 异步</h3><pre><code>代码在执行的过程中，会遇到一些无法立即处理的任务。比如：
计时完成后需要执行的任务 -- setTimeout、setInterval
网络通信完成后需要执行的任务 -- XHR、Fetch
用户操作后需要执行的任务 -- addEventListener

如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于【阻塞】的状态，从而导致浏览器【卡死】
</code></pre><h3 id="_3-事件循环" tabindex="-1"><a class="header-anchor" href="#_3-事件循环" aria-hidden="true">#</a> 3. 事件循环</h3><pre><code>1. 最开始的时候，渲染主进程会进入一个无限循环
2. 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完以后进入下一个循环；如果没有，则进入休眠状态。
3. 其他所有进程可以随时向消息队列添加任务。新任务会加入到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会唤醒以继续循环拿取任务。
这样一来，就可以让每个任务有条不紊的、持续的进行下去了。
整个过程，被称为事件循环（消息循环）。
</code></pre><h3 id="_3-js的异步" tabindex="-1"><a class="header-anchor" href="#_3-js的异步" aria-hidden="true">#</a> 3. js的异步</h3><pre><code>js是一门单线程的语言，这是因为他运行在浏览器的渲染主进程中，而渲染主线程只有一个。
而渲染主线程承担着诸多的工作，渲染页面、执行js等。
如果使用同步的方式，则极有可能导致主线程产生阻塞，从而导致消息队列中很多其他任务无法得到执行。
这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。
所以浏览器采用异步的方式来避免。具体的做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续的代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程的调度执行。
在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。
</code></pre><h3 id="_4-任务的优先级" tabindex="-1"><a class="header-anchor" href="#_4-任务的优先级" aria-hidden="true">#</a> 4. 任务的优先级</h3><pre><code>任务是没有优先级的，在消息队列中先进先出。
</code></pre><h3 id="_5-消息队列是有优先级的" tabindex="-1"><a class="header-anchor" href="#_5-消息队列是有优先级的" aria-hidden="true">#</a> 5. 消息队列是有优先级的</h3><pre><code>每一个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属不同的队列，在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
浏览器必须准备好一个微队列，优先于其他所有任务执行。
（由于浏览器的复杂度急剧提升，w3c不再采用宏队列的说法）
</code></pre><h3 id="_6-面试题" tabindex="-1"><a class="header-anchor" href="#_6-面试题" aria-hidden="true">#</a> 6. 面试题</h3><h4 id="_1-说一下js的事件循环" tabindex="-1"><a class="header-anchor" href="#_1-说一下js的事件循环" aria-hidden="true">#</a> 1. 说一下js的事件循环？</h4><pre><code>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
在谷歌浏览器的源码中，它会开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到消息队列的末尾即可。
过去把消息队列简单分为宏队列和微队列，这种说法目前已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
根据w3c的官方解释，每个任务有不同的类型。同一个类型的任务必须在同一个队列。不同的任务可以属于不同的队列。再一次事件循环中，由浏览器自行决定取哪一个队列的任务。但是浏览器必须有一个微队列，是最高的优先级。
</code></pre><h4 id="_2-js的计时器能精确计时吗-为什么" tabindex="-1"><a class="header-anchor" href="#_2-js的计时器能精确计时吗-为什么" aria-hidden="true">#</a> 2. js的计时器能精确计时吗，为什么？</h4><pre><code>不行。
1. 计算机硬件中没有原子钟，无法做到精确计时。
2. 操作系统的计时函数本身就有少量变差。由于js的计时器最终调用的是操作系统的函数，也就携带了这些偏差。
3. 按照w3c的标准，浏览器实现计时器时，如果嵌套层级超过5层，则会带有4毫秒的最少时间，在计时少于4毫秒的时候，又带来了偏差。
4. 受事件循环的影响，计时器的回调函数只能在主线程的空闲时运行，因此又有了偏差。
</code></pre>`,18),c=[h];function i(s,t){return a(),n("div",null,c)}const _=e(d,[["render",i],["__file","shijianxunhuan.html.vue"]]);export{_ as default};
